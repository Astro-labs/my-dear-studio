patch-package
--- a/node_modules/gatsby/dist/schema/infer-graphql-input-fields-from-fields.js
+++ b/node_modules/gatsby/dist/schema/infer-graphql-input-fields-from-fields.js
@@ -1,82 +1,84 @@
-"use strict";
+'use strict'
 
-exports.__esModule = true;
+exports.__esModule = true
 
-var _extends2 = require("babel-runtime/helpers/extends");
+var _extends2 = require('babel-runtime/helpers/extends')
 
-var _extends3 = _interopRequireDefault(_extends2);
+var _extends3 = _interopRequireDefault(_extends2)
 
-exports.inferInputObjectStructureFromFields = inferInputObjectStructureFromFields;
+exports.inferInputObjectStructureFromFields = inferInputObjectStructureFromFields
 
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+function _interopRequireDefault(obj) {
+  return obj && obj.__esModule ? obj : { default: obj }
+}
 
 var _require = require(`graphql`),
-    GraphQLInputObjectType = _require.GraphQLInputObjectType,
-    GraphQLBoolean = _require.GraphQLBoolean,
-    GraphQLString = _require.GraphQLString,
-    GraphQLFloat = _require.GraphQLFloat,
-    GraphQLInt = _require.GraphQLInt,
-    GraphQLID = _require.GraphQLID,
-    GraphQLList = _require.GraphQLList,
-    GraphQLEnumType = _require.GraphQLEnumType,
-    GraphQLNonNull = _require.GraphQLNonNull,
-    GraphQLScalarType = _require.GraphQLScalarType,
-    GraphQLObjectType = _require.GraphQLObjectType,
-    GraphQLInterfaceType = _require.GraphQLInterfaceType,
-    GraphQLUnionType = _require.GraphQLUnionType;
-
-var _ = require(`lodash`);
-var report = require(`gatsby-cli/lib/reporter`);
-var createTypeName = require(`./create-type-name`);
-var createKey = require(`./create-key`);
+  GraphQLInputObjectType = _require.GraphQLInputObjectType,
+  GraphQLBoolean = _require.GraphQLBoolean,
+  GraphQLString = _require.GraphQLString,
+  GraphQLFloat = _require.GraphQLFloat,
+  GraphQLInt = _require.GraphQLInt,
+  GraphQLID = _require.GraphQLID,
+  GraphQLList = _require.GraphQLList,
+  GraphQLEnumType = _require.GraphQLEnumType,
+  GraphQLNonNull = _require.GraphQLNonNull,
+  GraphQLScalarType = _require.GraphQLScalarType,
+  GraphQLObjectType = _require.GraphQLObjectType,
+  GraphQLInterfaceType = _require.GraphQLInterfaceType,
+  GraphQLUnionType = _require.GraphQLUnionType
+
+var _ = require(`lodash`)
+var report = require(`gatsby-cli/lib/reporter`)
+var createTypeName = require(`./create-type-name`)
+var createKey = require(`./create-key`)
 
 function makeNullable(type) {
   if (type instanceof GraphQLNonNull) {
-    return type.ofType;
+    return type.ofType
   }
-  return type;
+  return type
 }
 
 function convertToInputType(type, typeMap) {
   // track types already processed in current tree, to avoid infinite recursion
   if (typeMap.has(type)) {
-    return null;
+    return null
   }
-  var nextTypeMap = new Set(Array.from(typeMap).concat([type]));
+  var nextTypeMap = new Set(Array.from(typeMap).concat([type]))
 
   if (type instanceof GraphQLScalarType || type instanceof GraphQLEnumType) {
-    return type;
+    return type
   } else if (type instanceof GraphQLObjectType) {
-    var fields = _.transform(type.getFields(), function (out, fieldConfig, key) {
-      var type = convertToInputType(fieldConfig.type, nextTypeMap);
-      if (type) out[key] = { type };
-    });
+    var fields = _.transform(type.getFields(), function(out, fieldConfig, key) {
+      var type = convertToInputType(fieldConfig.type, nextTypeMap)
+      if (type) out[key] = { type }
+    })
     if (Object.keys(fields).length === 0) {
-      return null;
+      return null
     }
     return new GraphQLInputObjectType({
       name: createTypeName(`${type.name}InputObject`),
-      fields
-    });
+      fields,
+    })
   } else if (type instanceof GraphQLList) {
-    var innerType = convertToInputType(type.ofType, nextTypeMap);
-    return innerType ? new GraphQLList(makeNullable(innerType)) : null;
+    var innerType = convertToInputType(type.ofType, nextTypeMap)
+    return innerType ? new GraphQLList(makeNullable(innerType)) : null
   } else if (type instanceof GraphQLNonNull) {
-    var _innerType = convertToInputType(type.ofType, nextTypeMap);
-    return _innerType ? new GraphQLNonNull(makeNullable(_innerType)) : null;
+    var _innerType = convertToInputType(type.ofType, nextTypeMap)
+    return _innerType ? new GraphQLNonNull(makeNullable(_innerType)) : null
   } else {
-    var message = type ? `for type: ${type.name}` : ``;
+    var message = type ? `for type: ${type.name}` : ``
     if (type instanceof GraphQLInterfaceType) {
-      message = `GraphQLInterfaceType not yet implemented ${message}`;
+      message = `GraphQLInterfaceType not yet implemented ${message}`
     } else if (type instanceof GraphQLUnionType) {
-      message = `GraphQLUnionType not yet implemented ${message}`;
+      message = `GraphQLUnionType not yet implemented ${message}`
     } else {
-      message = `Invalid input type ${message}`;
+      message = `Invalid input type ${message}`
     }
-    report.verbose(message);
+    report.verbose(message)
   }
 
-  return null;
+  return null
 }
 
 var scalarFilterMap = {
@@ -86,7 +88,7 @@ var scalarFilterMap = {
     gt: { type: GraphQLInt },
     gte: { type: GraphQLInt },
     lt: { type: GraphQLInt },
-    lte: { type: GraphQLInt }
+    lte: { type: GraphQLInt },
   },
   Float: {
     eq: { type: GraphQLFloat },
@@ -94,95 +96,103 @@ var scalarFilterMap = {
     gt: { type: GraphQLFloat },
     gte: { type: GraphQLFloat },
     lt: { type: GraphQLFloat },
-    lte: { type: GraphQLFloat }
+    lte: { type: GraphQLFloat },
   },
   ID: {
     eq: { type: GraphQLID },
-    ne: { type: GraphQLID }
+    ne: { type: GraphQLID },
   },
   String: {
     eq: { type: GraphQLString },
     ne: { type: GraphQLString },
     regex: { type: GraphQLString },
-    glob: { type: GraphQLString }
+    glob: { type: GraphQLString },
   },
   Boolean: {
     eq: { type: GraphQLBoolean },
-    ne: { type: GraphQLBoolean }
-  }
-};
+    ne: { type: GraphQLBoolean },
+  },
+}
 
 function convertToInputFilter(prefix, type) {
   if (type instanceof GraphQLScalarType) {
-    var name = type.name;
-    var fields = scalarFilterMap[name];
+    var name = type.name
+    var fields = scalarFilterMap[name]
 
-    if (fields == null) return null;
+    if (fields == null) return null
     return new GraphQLInputObjectType({
       name: createTypeName(`${prefix}Query${name}`),
-      fields: fields
-    });
+      fields: fields,
+    })
   } else if (type instanceof GraphQLInputObjectType) {
     return new GraphQLInputObjectType({
       name: createTypeName(`${prefix}{type.name}`),
-      fields: _.transform(type.getFields(), function (out, fieldConfig, key) {
-        var type = convertToInputFilter(`${prefix}${_.upperFirst(key)}`, fieldConfig.type);
-        if (type) out[key] = { type };
-      })
-    });
+      fields: _.transform(type.getFields(), function(out, fieldConfig, key) {
+        var type = convertToInputFilter(`${prefix}${_.upperFirst(key)}`, fieldConfig.type)
+        if (type) out[key] = { type }
+      }),
+    })
   } else if (type instanceof GraphQLList) {
-    var innerType = type.ofType;
-    var innerFilter = convertToInputFilter(`${prefix}ListElem`, innerType);
-    var innerFields = innerFilter ? innerFilter.getFields() : {};
+    var innerType = type.ofType
+    var innerFilter = convertToInputFilter(`${prefix}ListElem`, innerType)
+    var innerFields = innerFilter ? innerFilter.getFields() : {}
+    var fields =
+      innerType instanceof GraphQLInputObjectType
+        ? {
+            elemMatch: { type: innerFilter },
+          }
+        : (0, _extends3.default)({}, innerFields, {
+            in: { type: new GraphQLList(innerType) },
+          })
 
     return new GraphQLInputObjectType({
       name: createTypeName(`${prefix}QueryList`),
-      fields: (0, _extends3.default)({}, innerFields, {
-        in: { type: new GraphQLList(innerType) }
-      })
-    });
+      fields,
+    })
   } else if (type instanceof GraphQLNonNull) {
-    return convertToInputFilter(prefix, type.ofType);
+    return convertToInputFilter(prefix, type.ofType)
   }
 
-  return null;
+  return null
 }
 
 function extractFieldNamesFromInputField(prefix, type, accu) {
   if (type instanceof GraphQLScalarType || type instanceof GraphQLList) {
-    accu.push(prefix);
+    accu.push(prefix)
   } else if (type instanceof GraphQLInputObjectType) {
-    _.each(type.getFields(), function (fieldConfig, key) {
-      extractFieldNamesFromInputField(`${prefix}___${key}`, fieldConfig.type, accu);
-    });
+    _.each(type.getFields(), function(fieldConfig, key) {
+      extractFieldNamesFromInputField(`${prefix}___${key}`, fieldConfig.type, accu)
+    })
   } else if (type instanceof GraphQLNonNull) {
-    extractFieldNamesFromInputField(prefix, type.ofType, accu);
+    extractFieldNamesFromInputField(prefix, type.ofType, accu)
   }
 }
 
 // convert output fields to output fields and a list of fields to sort on
 function inferInputObjectStructureFromFields(_ref) {
   var fields = _ref.fields,
-      _ref$typeName = _ref.typeName,
-      typeName = _ref$typeName === undefined ? `` : _ref$typeName;
+    _ref$typeName = _ref.typeName,
+    typeName = _ref$typeName === undefined ? `` : _ref$typeName
 
-  var inferredFields = {};
-  var sort = [];
+  var inferredFields = {}
+  var sort = []
 
-  _.each(fields, function (fieldConfig, key) {
-    var inputType = convertToInputType(fieldConfig.type, new Set());
-    var inputFilter = inputType && convertToInputFilter(_.upperFirst(key), inputType);
+  _.each(fields, function(fieldConfig, key) {
+    var inputType = convertToInputType(fieldConfig.type, new Set())
+    var inputFilter = inputType && convertToInputFilter(_.upperFirst(key), inputType)
 
-    if (!inputFilter) return;
+    if (!inputFilter) return
 
-    inferredFields[createKey(key)] = { type: inputFilter
+    inferredFields[createKey(key)] = {
+      type: inputFilter,
 
       // Add sorting (but only to the top level).
-    };if (typeName) {
-      extractFieldNamesFromInputField(key, inputType, sort);
     }
-  });
+    if (typeName) {
+      extractFieldNamesFromInputField(key, inputType, sort)
+    }
+  })
 
-  return { inferredFields, sort };
+  return { inferredFields, sort }
 }
 //# sourceMappingURL=infer-graphql-input-fields-from-fields.js.map
--- a/node_modules/gatsby/dist/schema/infer-graphql-input-fields.js
+++ b/node_modules/gatsby/dist/schema/infer-graphql-input-fields.js
@@ -1,57 +1,59 @@
-"use strict";
+'use strict'
 
-exports.__esModule = true;
+exports.__esModule = true
 
-var _extends2 = require("babel-runtime/helpers/extends");
+var _extends2 = require('babel-runtime/helpers/extends')
 
-var _extends3 = _interopRequireDefault(_extends2);
+var _extends3 = _interopRequireDefault(_extends2)
 
-exports.inferInputObjectStructureFromNodes = inferInputObjectStructureFromNodes;
+exports.inferInputObjectStructureFromNodes = inferInputObjectStructureFromNodes
 
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+function _interopRequireDefault(obj) {
+  return obj && obj.__esModule ? obj : { default: obj }
+}
 
 var _require = require(`graphql`),
-    GraphQLInputObjectType = _require.GraphQLInputObjectType,
-    GraphQLBoolean = _require.GraphQLBoolean,
-    GraphQLString = _require.GraphQLString,
-    GraphQLFloat = _require.GraphQLFloat,
-    GraphQLInt = _require.GraphQLInt,
-    GraphQLList = _require.GraphQLList;
+  GraphQLInputObjectType = _require.GraphQLInputObjectType,
+  GraphQLBoolean = _require.GraphQLBoolean,
+  GraphQLString = _require.GraphQLString,
+  GraphQLFloat = _require.GraphQLFloat,
+  GraphQLInt = _require.GraphQLInt,
+  GraphQLList = _require.GraphQLList
 
 var _require2 = require(`common-tags`),
-    oneLine = _require2.oneLine;
+  oneLine = _require2.oneLine
 
-var _ = require(`lodash`);
-var invariant = require(`invariant`);
-var typeOf = require(`type-of`);
-var createTypeName = require(`./create-type-name`);
-var createKey = require(`./create-key`);
+var _ = require(`lodash`)
+var invariant = require(`invariant`)
+var typeOf = require(`type-of`)
+var createTypeName = require(`./create-type-name`)
+var createKey = require(`./create-key`)
 
 var _require3 = require(`./data-tree-utils`),
-    getExampleValues = _require3.getExampleValues,
-    extractFieldNames = _require3.extractFieldNames,
-    isEmptyObjectOrArray = _require3.isEmptyObjectOrArray;
+  getExampleValues = _require3.getExampleValues,
+  extractFieldNames = _require3.extractFieldNames,
+  isEmptyObjectOrArray = _require3.isEmptyObjectOrArray
 
 var _require4 = require(`./infer-graphql-type`),
-    findLinkedNode = _require4.findLinkedNode;
+  findLinkedNode = _require4.findLinkedNode
 
 var _require5 = require(`../redux`),
-    getNodes = _require5.getNodes;
+  getNodes = _require5.getNodes
 
 function typeFields(type) {
   switch (type) {
     case `boolean`:
       return {
         eq: { type: GraphQLBoolean },
-        ne: { type: GraphQLBoolean }
-      };
+        ne: { type: GraphQLBoolean },
+      }
     case `string`:
       return {
         eq: { type: GraphQLString },
         ne: { type: GraphQLString },
         regex: { type: GraphQLString },
-        glob: { type: GraphQLString }
-      };
+        glob: { type: GraphQLString },
+      }
     case `int`:
       return {
         eq: { type: GraphQLInt },
@@ -59,8 +61,8 @@ function typeFields(type) {
         gt: { type: GraphQLInt },
         gte: { type: GraphQLInt },
         lt: { type: GraphQLInt },
-        lte: { type: GraphQLInt }
-      };
+        lte: { type: GraphQLInt },
+      }
     case `float`:
       return {
         eq: { type: GraphQLFloat },
@@ -68,231 +70,236 @@ function typeFields(type) {
         gt: { type: GraphQLFloat },
         gte: { type: GraphQLFloat },
         lt: { type: GraphQLFloat },
-        lte: { type: GraphQLFloat }
-      };
+        lte: { type: GraphQLFloat },
+      }
   }
-  return {};
+  return {}
 }
 
 function inferGraphQLInputFields(_ref) {
   var value = _ref.value,
-      nodes = _ref.nodes,
-      prefix = _ref.prefix;
+    nodes = _ref.nodes,
+    prefix = _ref.prefix
 
-  if (value == null || isEmptyObjectOrArray(value)) return null;
+  if (value == null || isEmptyObjectOrArray(value)) return null
 
   switch (typeOf(value)) {
-    case `array`:
-      {
-        var headValue = value[0];
-        var headType = typeOf(headValue);
-
-        if (headType === `number`) headType = _.isInteger(headValue) ? `int` : `float`;
-
-        // Determine type for in operator.
-        var inType = void 0;
-        switch (headType) {
-          case `int`:
-            inType = GraphQLInt;
-            break;
-          case `float`:
-            inType = GraphQLFloat;
-            break;
-          case `date`:
-          case `string`:
-            inType = GraphQLString;
-            break;
-          case `boolean`:
-            inType = GraphQLBoolean;
-            break;
-          case `array`:
-          case `object`:
-            {
-              var inferredField = inferGraphQLInputFields({
-                value: headValue,
-                prefix,
-                nodes
-              });
-              invariant(inferredField, `Could not infer graphQL type for value: ${JSON.stringify(Object.keys(headValue))}`);
-              inType = inferredField.type;
-              break;
-            }
-          default:
-            invariant(false, oneLine`
+    case `array`: {
+      var headValue = value[0]
+      var headType = typeOf(headValue)
+
+      if (headType === `number`) headType = _.isInteger(headValue) ? `int` : `float`
+
+      // Determine type for in operator.
+      var inType = void 0
+      switch (headType) {
+        case `int`:
+          inType = GraphQLInt
+          break
+        case `float`:
+          inType = GraphQLFloat
+          break
+        case `date`:
+        case `string`:
+          inType = GraphQLString
+          break
+        case `boolean`:
+          inType = GraphQLBoolean
+          break
+        case `array`:
+        case `object`: {
+          var inferredField = inferGraphQLInputFields({
+            value: headValue,
+            prefix,
+            nodes,
+          })
+          invariant(inferredField, `Could not infer graphQL type for value: ${JSON.stringify(Object.keys(headValue))}`)
+          inType = inferredField.type
+          break
+        }
+        default:
+          invariant(
+            false,
+            oneLine`
               Could not infer an appropriate GraphQL input type
               for value: ${headValue} of type ${headType} along path: ${prefix}
-            `);
-        }
+            `,
+          )
+      }
 
-        return {
-          type: new GraphQLInputObjectType({
-            name: createTypeName(`${prefix}QueryList`),
-            fields: (0, _extends3.default)({}, typeFields(headType), {
-              in: { type: new GraphQLList(inType) }
+      var fields =
+        headType === `object`
+          ? {
+              elemMatch: {
+                type: inType,
+              },
+            }
+          : (0, _extends3.default)({}, typeFields(headType), {
+              in: { type: new GraphQLList(inType) },
             })
-          })
-        };
+
+      return {
+        type: new GraphQLInputObjectType({
+          name: createTypeName(`${prefix}QueryList`),
+          fields,
+        }),
       }
-    case `boolean`:
-      {
-        return {
-          type: new GraphQLInputObjectType({
-            name: createTypeName(`${prefix}QueryBoolean`),
-            fields: typeFields(`boolean`)
-          })
-        };
+    }
+    case `boolean`: {
+      return {
+        type: new GraphQLInputObjectType({
+          name: createTypeName(`${prefix}QueryBoolean`),
+          fields: typeFields(`boolean`),
+        }),
       }
+    }
     case `date`:
-    case `string`:
-      {
+    case `string`: {
+      return {
+        type: new GraphQLInputObjectType({
+          name: createTypeName(`${prefix}QueryString`),
+          fields: typeFields(`string`),
+        }),
+      }
+    }
+    case `object`: {
+      var fields = inferInputObjectStructureFromNodes({
+        nodes,
+        prefix,
+        exampleValue: value,
+      }).inferredFields
+      if (!_.isEmpty(fields)) {
         return {
           type: new GraphQLInputObjectType({
-            name: createTypeName(`${prefix}QueryString`),
-            fields: typeFields(`string`)
-          })
-        };
-      }
-    case `object`:
-      {
-        var fields = inferInputObjectStructureFromNodes({
-          nodes,
-          prefix,
-          exampleValue: value
-        }).inferredFields;
-        if (!_.isEmpty(fields)) {
-          return {
-            type: new GraphQLInputObjectType({
-              name: createTypeName(`${prefix}InputObject`),
-              fields
-            })
-          };
-        } else {
-          return null;
+            name: createTypeName(`${prefix}InputObject`),
+            fields,
+          }),
         }
+      } else {
+        return null
       }
-    case `number`:
-      {
-        if (value % 1 === 0) {
-          return {
-            type: new GraphQLInputObjectType({
-              name: createTypeName(`${prefix}QueryInteger`),
-              fields: typeFields(`int`)
-            })
-          };
-        } else {
-          return {
-            type: new GraphQLInputObjectType({
-              name: createTypeName(`${prefix}QueryFloat`),
-              fields: typeFields(`float`)
-            })
-          };
+    }
+    case `number`: {
+      if (value % 1 === 0) {
+        return {
+          type: new GraphQLInputObjectType({
+            name: createTypeName(`${prefix}QueryInteger`),
+            fields: typeFields(`int`),
+          }),
+        }
+      } else {
+        return {
+          type: new GraphQLInputObjectType({
+            name: createTypeName(`${prefix}QueryFloat`),
+            fields: typeFields(`float`),
+          }),
         }
       }
+    }
     default:
-      return null;
+      return null
   }
 }
 
 var EXCLUDE_KEYS = {
   parent: 1,
-  children: 1
-};
+  children: 1,
+}
 
 var recursiveOmitBy = function recursiveOmitBy(value, fn) {
   if (_.isObject(value)) {
     if (_.isPlainObject(value)) {
-      value = _.omitBy(value, fn);
+      value = _.omitBy(value, fn)
     }
-    _.each(value, function (v, k) {
-      value[k] = recursiveOmitBy(v, fn);
-    });
+    _.each(value, function(v, k) {
+      value[k] = recursiveOmitBy(v, fn)
+    })
     if (_.isEmpty(value)) {
       // don't return empty objects - gatsby doesn't support these
-      return null;
+      return null
     }
   }
-  return value;
-};
+  return value
+}
 
-var linkedNodeCache = {};
+var linkedNodeCache = {}
 
 function inferInputObjectStructureFromNodes(_ref2) {
   var nodes = _ref2.nodes,
-      _ref2$typeName = _ref2.typeName,
-      typeName = _ref2$typeName === undefined ? `` : _ref2$typeName,
-      _ref2$prefix = _ref2.prefix,
-      prefix = _ref2$prefix === undefined ? `` : _ref2$prefix,
-      _ref2$exampleValue = _ref2.exampleValue,
-      exampleValue = _ref2$exampleValue === undefined ? null : _ref2$exampleValue;
+    _ref2$typeName = _ref2.typeName,
+    typeName = _ref2$typeName === undefined ? `` : _ref2$typeName,
+    _ref2$prefix = _ref2.prefix,
+    prefix = _ref2$prefix === undefined ? `` : _ref2$prefix,
+    _ref2$exampleValue = _ref2.exampleValue,
+    exampleValue = _ref2$exampleValue === undefined ? null : _ref2$exampleValue
 
-  var inferredFields = {};
-  var isRoot = !prefix;
+  var inferredFields = {}
+  var isRoot = !prefix
 
-  prefix = isRoot ? typeName : prefix;
+  prefix = isRoot ? typeName : prefix
   if (exampleValue === null) {
     // typeName includes "Connection" string, which is not what we want,
     // so extract type from first node
     exampleValue = getExampleValues({
       nodes,
-      typeName: nodes && nodes[0] && nodes[0].internal && nodes[0].internal.type
-    });
+      typeName: nodes && nodes[0] && nodes[0].internal && nodes[0].internal.type,
+    })
   }
 
-  _.each(exampleValue, function (v, k) {
-    var value = v;
-    var key = k;
+  _.each(exampleValue, function(v, k) {
+    var value = v
+    var key = k
     // Remove fields for traversing through nodes as we want to control
     // setting traversing up not try to automatically infer them.
-    if (isRoot && EXCLUDE_KEYS[key]) return;
+    if (isRoot && EXCLUDE_KEYS[key]) return
 
     if (_.includes(key, `___NODE`)) {
       // TODO: Union the objects in array
-      var nodeToFind = _.isArray(value) ? value[0] : value;
-      var linkedNode = findLinkedNode(nodeToFind);
+      var nodeToFind = _.isArray(value) ? value[0] : value
+      var linkedNode = findLinkedNode(nodeToFind)
 
       // Get from cache if found, else store into it
       if (linkedNodeCache[linkedNode.internal.type]) {
-        value = linkedNodeCache[linkedNode.internal.type];
+        value = linkedNodeCache[linkedNode.internal.type]
       } else {
-        var relatedNodes = getNodes().filter(function (node) {
-          return node.internal.type === linkedNode.internal.type;
-        });
+        var relatedNodes = getNodes().filter(function(node) {
+          return node.internal.type === linkedNode.internal.type
+        })
         value = getExampleValues({
           nodes: relatedNodes,
-          typeName: linkedNode.internal.type
-        });
-        value = recursiveOmitBy(value, function (_v, _k) {
-          return _.includes(_k, `___NODE`);
-        });
-        linkedNodeCache[linkedNode.internal.type] = value;
+          typeName: linkedNode.internal.type,
+        })
+        value = recursiveOmitBy(value, function(_v, _k) {
+          return _.includes(_k, `___NODE`)
+        })
+        linkedNodeCache[linkedNode.internal.type] = value
       }
 
       if (_.isArray(value)) {
-        value = [value];
+        value = [value]
       }
 
-      ;
-      var _key$split = key.split(`___`);
+      var _key$split = key.split(`___`)
 
-      key = _key$split[0];
+      key = _key$split[0]
     }
 
     var field = inferGraphQLInputFields({
       nodes,
       value,
-      prefix: `${prefix}${_.upperFirst(key)}`
-    });
+      prefix: `${prefix}${_.upperFirst(key)}`,
+    })
 
-    if (field == null) return;
-    inferredFields[createKey(key)] = field;
-  });
+    if (field == null) return
+    inferredFields[createKey(key)] = field
+  })
 
   // Add sorting (but only to the top level).
-  var sort = [];
+  var sort = []
   if (typeName) {
-    sort = extractFieldNames(nodes);
+    sort = extractFieldNames(nodes)
   }
 
-  return { inferredFields, sort };
+  return { inferredFields, sort }
 }
 //# sourceMappingURL=infer-graphql-input-fields.js.map
--- a/node_modules/gatsby/dist/schema/run-sift.js
+++ b/node_modules/gatsby/dist/schema/run-sift.js
@@ -1,42 +1,46 @@
-"use strict";
+'use strict'
 
-var _extends2 = require("babel-runtime/helpers/extends");
+var _extends2 = require('babel-runtime/helpers/extends')
 
-var _extends3 = _interopRequireDefault(_extends2);
+var _extends3 = _interopRequireDefault(_extends2)
 
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+function _interopRequireDefault(obj) {
+  return obj && obj.__esModule ? obj : { default: obj }
+}
 
-var sift = require(`sift`);
-var _ = require(`lodash`);
+var sift = require(`sift`)
+var _ = require(`lodash`)
 
 var _require = require(`graphql-skip-limit`),
-    connectionFromArray = _require.connectionFromArray;
+  connectionFromArray = _require.connectionFromArray
 
 var _require2 = require(`../redux/actions/add-page-dependency`),
-    createPageDependency = _require2.createPageDependency;
+  createPageDependency = _require2.createPageDependency
 
-var prepareRegex = require(`./prepare-regex`);
-var Promise = require(`bluebird`);
+var prepareRegex = require(`./prepare-regex`)
+var Promise = require(`bluebird`)
 
 var _require3 = require(`./node-tracking`),
-    trackInlineObjectsInRootNode = _require3.trackInlineObjectsInRootNode;
+  trackInlineObjectsInRootNode = _require3.trackInlineObjectsInRootNode
 
-var enhancedNodeCache = new Map();
+var enhancedNodeCache = new Map()
 var enhancedNodeCacheId = function enhancedNodeCacheId(_ref) {
   var node = _ref.node,
-      args = _ref.args;
-  return node && node.internal && node.internal.contentDigest ? `${node.id}${node.internal.contentDigest}${JSON.stringify(args)}` : null;
-};
+    args = _ref.args
+  return node && node.internal && node.internal.contentDigest
+    ? `${node.id}${node.internal.contentDigest}${JSON.stringify(args)}`
+    : null
+}
 
 function awaitSiftField(fields, node, k) {
-  var field = fields[k];
+  var field = fields[k]
   if (field.resolve) {
-    return field.resolve(node, {}, {}, { fieldName: k });
+    return field.resolve(node, {}, {}, { fieldName: k })
   } else if (node[k] !== undefined) {
-    return node[k];
+    return node[k]
   }
 
-  return undefined;
+  return undefined
 }
 
 /*
@@ -44,149 +48,166 @@ function awaitSiftField(fields, node, k) {
 * Returns a single unwrapped element if connection = false.
 *
 */
-module.exports = function (_ref2) {
+module.exports = function(_ref2) {
   var args = _ref2.args,
-      nodes = _ref2.nodes,
-      type = _ref2.type,
-      _ref2$connection = _ref2.connection,
-      connection = _ref2$connection === undefined ? false : _ref2$connection,
-      _ref2$path = _ref2.path,
-      path = _ref2$path === undefined ? `` : _ref2$path;
+    nodes = _ref2.nodes,
+    type = _ref2.type,
+    _ref2$connection = _ref2.connection,
+    connection = _ref2$connection === undefined ? false : _ref2$connection,
+    _ref2$path = _ref2.path,
+    path = _ref2$path === undefined ? `` : _ref2$path
 
   // Clone args as for some reason graphql-js removes the constructor
   // from nested objects which breaks a check in sift.js.
-  var clonedArgs = JSON.parse(JSON.stringify(args));
+  var clonedArgs = JSON.parse(JSON.stringify(args))
 
   var siftifyArgs = function siftifyArgs(object) {
-    var newObject = {};
-    _.each(object, function (v, k) {
-      if (_.isObject(v) && !_.isArray(v)) {
-        newObject[k] = siftifyArgs(v);
+    var newObject = {}
+    _.each(object, function(v, k) {
+      if (_.isPlainObject(v)) {
+        if (k === `elemMatch`) {
+          k = `$elemMatch`
+        }
+        newObject[k] = siftifyArgs(v)
       } else {
         // Compile regex first.
         if (k === `regex`) {
-          newObject[`$regex`] = prepareRegex(v);
+          newObject[`$regex`] = prepareRegex(v)
         } else if (k === `glob`) {
-          var Minimatch = require(`minimatch`).Minimatch;
-          var mm = new Minimatch(v);
-          newObject[`$regex`] = mm.makeRe();
+          var Minimatch = require(`minimatch`).Minimatch
+          var mm = new Minimatch(v)
+          newObject[`$regex`] = mm.makeRe()
         } else {
-          newObject[`$${k}`] = v;
+          newObject[`$${k}`] = v
         }
       }
-    });
-    return newObject;
-  };
+    })
+    return newObject
+  }
 
   // Build an object that excludes the innermost leafs,
   // this avoids including { eq: x } when resolving fields.
   function extractFieldsToSift(prekey, key, preobj, obj, val) {
-    if (_.isObject(val) && !_.isArray(val)) {
-      _.forEach(val, function (v, k) {
-        preobj[prekey] = obj;
-        extractFieldsToSift(key, k, obj, {}, v);
-      });
+    if (_.isPlainObject(val)) {
+      _.forEach(val, function(v, k) {
+        preobj[prekey] = obj
+        extractFieldsToSift(key, k, obj, {}, v)
+      })
     } else {
-      preobj[prekey] = true;
+      preobj[prekey] = true
     }
   }
 
-  var siftArgs = [];
-  var fieldsToSift = {};
+  var siftArgs = []
+  var fieldsToSift = {}
   if (clonedArgs.filter) {
-    _.each(clonedArgs.filter, function (v, k) {
+    _.each(clonedArgs.filter, function(v, k) {
       // Ignore connection and sorting args.
-      if (_.includes([`skip`, `limit`, `sort`], k)) return;
+      if (_.includes([`skip`, `limit`, `sort`], k)) return
 
-      siftArgs.push(siftifyArgs({ [k]: v }));
-      extractFieldsToSift(``, k, {}, fieldsToSift, v);
-    });
+      siftArgs.push(siftifyArgs({ [k]: v }))
+      extractFieldsToSift(``, k, {}, fieldsToSift, v)
+    })
   }
 
   // Resolves every field used in the node.
   function resolveRecursive(node, siftFieldsObj, gqFields) {
-    return Promise.all(_.keys(siftFieldsObj).map(function (k) {
-      return Promise.resolve(awaitSiftField(gqFields, node, k)).then(function (v) {
-        var innerSift = siftFieldsObj[k];
-        var innerGqConfig = gqFields[k];
-        if (_.isObject(innerSift) && v != null && innerGqConfig && innerGqConfig.type && _.isFunction(innerGqConfig.type.getFields)) {
-          return resolveRecursive(v, innerSift, innerGqConfig.type.getFields());
-        } else {
-          return v;
-        }
-      }).then(function (v) {
-        return [k, v];
-      });
-    })).then(function (resolvedFields) {
-      var myNode = (0, _extends3.default)({}, node);
-      resolvedFields.forEach(function (_ref3) {
+    return Promise.all(
+      _.keys(siftFieldsObj).map(function(k) {
+        return Promise.resolve(awaitSiftField(gqFields, node, k))
+          .then(function(v) {
+            var innerSift = siftFieldsObj[k]
+            var innerGqConfig = gqFields[k]
+            if (
+              _.isObject(innerSift) &&
+              v != null &&
+              innerGqConfig &&
+              innerGqConfig.type &&
+              _.isFunction(innerGqConfig.type.getFields)
+            ) {
+              return resolveRecursive(v, innerSift, innerGqConfig.type.getFields())
+            } else {
+              return v
+            }
+          })
+          .then(function(v) {
+            return [k, v]
+          })
+      }),
+    ).then(function(resolvedFields) {
+      var myNode = (0, _extends3.default)({}, node)
+      resolvedFields.forEach(function(_ref3) {
         var k = _ref3[0],
-            v = _ref3[1];
-        return myNode[k] = v;
-      });
-      return myNode;
-    });
+          v = _ref3[1]
+        return (myNode[k] = v)
+      })
+      return myNode
+    })
   }
 
-  return Promise.all(nodes.map(function (node) {
-    var cacheKey = enhancedNodeCacheId({ node, args: fieldsToSift });
-    if (cacheKey && enhancedNodeCache.has(cacheKey)) {
-      return Promise.resolve(enhancedNodeCache.get(cacheKey));
-    }
-
-    return resolveRecursive(node, fieldsToSift, type.getFields()).then(function (resolvedNode) {
-      trackInlineObjectsInRootNode(resolvedNode);
-      if (cacheKey) {
-        enhancedNodeCache.set(cacheKey, resolvedNode);
+  return Promise.all(
+    nodes.map(function(node) {
+      var cacheKey = enhancedNodeCacheId({ node, args: fieldsToSift })
+      if (cacheKey && enhancedNodeCache.has(cacheKey)) {
+        return Promise.resolve(enhancedNodeCache.get(cacheKey))
       }
-      return resolvedNode;
-    });
-  })).then(function (myNodes) {
+
+      return resolveRecursive(node, fieldsToSift, type.getFields()).then(function(resolvedNode) {
+        trackInlineObjectsInRootNode(resolvedNode)
+        if (cacheKey) {
+          enhancedNodeCache.set(cacheKey, resolvedNode)
+        }
+        return resolvedNode
+      })
+    }),
+  ).then(function(myNodes) {
     if (!connection) {
-      var index = _.isEmpty(siftArgs) ? 0 : sift.indexOf({ $and: siftArgs }, myNodes);
+      var index = _.isEmpty(siftArgs) ? 0 : sift.indexOf({ $and: siftArgs }, myNodes)
 
       // If a node is found, create a dependency between the resulting node and
       // the path.
       if (index !== -1) {
         createPageDependency({
           path,
-          nodeId: myNodes[index].id
-        });
+          nodeId: myNodes[index].id,
+        })
 
-        return myNodes[index];
+        return myNodes[index]
       } else {
-        return null;
+        return null
       }
     }
 
-    var result = _.isEmpty(siftArgs) ? myNodes : sift({ $and: siftArgs }, myNodes);
+    var result = _.isEmpty(siftArgs) ? myNodes : sift({ $and: siftArgs }, myNodes)
 
-    if (!result || !result.length) return null;
+    if (!result || !result.length) return null
 
     // Sort results.
     if (clonedArgs.sort) {
       // create functions that return the item to compare on
       // uses _.get so nested fields can be retrieved
-      var convertedFields = clonedArgs.sort.fields.map(function (field) {
-        return field.replace(/___/g, `.`);
-      }).map(function (field) {
-        return function (v) {
-          return _.get(v, field);
-        };
-      });
-
-      result = _.orderBy(result, convertedFields, clonedArgs.sort.order);
+      var convertedFields = clonedArgs.sort.fields
+        .map(function(field) {
+          return field.replace(/___/g, `.`)
+        })
+        .map(function(field) {
+          return function(v) {
+            return _.get(v, field)
+          }
+        })
+
+      result = _.orderBy(result, convertedFields, clonedArgs.sort.order)
     }
 
-    var connectionArray = connectionFromArray(result, args);
-    connectionArray.totalCount = result.length;
+    var connectionArray = connectionFromArray(result, args)
+    connectionArray.totalCount = result.length
     if (result.length > 0 && result[0].internal) {
       createPageDependency({
         path,
-        connection: result[0].internal.type
-      });
+        connection: result[0].internal.type,
+      })
     }
-    return connectionArray;
-  });
-};
+    return connectionArray
+  })
+}
 //# sourceMappingURL=run-sift.js.map
